\section{Time-of-check to time-of-use}

As the name implies, this condition arises when a certain value is checked (e.g. to verify that it satisfies a condition) and then it is used to perform some operation. If the \textit{check} and the \textit{use} instructions are distinct and do not constitute a single atomic operation, a race condition could allow modification of the value after it is checked and before it is used.

\subsection{TOC/TOU example \citep{courseslides}}

Consider the following PHP code snippet handling a money transfer between two customers of the same bank. \textsc{a} has 500\$ in her account and she wants to transfer 400\$ to \textsc{b}'s account, which is currently empty.

\begin{minted}[startinline, samepage]{php}
// Check if A's balance is sufficient
$balanceA = query("SELECT balance FROM users WHERE id = A");
if ($balanceA < 400) {
    die("Insufficient balance");
}

// Calculate A's new balance
$balanceA -= 400;

// Store money transfer
query("UPDATE users SET balance = $balanceA WHERE id = A");
query("UPDATE users SET balance = balance + 400 WHERE id = B");
\end{minted}

Assume that \textsc{a} mistakenly (or purposely) requests the operation two times in a row (e.g. by clicking the ``Confirm'' button twice on her home banking application), resulting in two (asynchronous) requests being sent to the server. In the worst case, the following could happen:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\thead[c]{\textbf{First request}} & \thead[c]{\textbf{Second request}} \\ \hline
\makecell[tl]{Check \textsc{a}'s balance \\ \hspace{12px} (\texttt{A=500, B=0, \$balanceA=500})} & \\
& \makecell[tl]{Check \textsc{a}'s balance \\ \hspace{12px} (\texttt{A=500, B=0, \$balanceA=500})}  \\
\makecell[tl]{Calculate \textsc{a}'s new balance \\ \hspace{12px} (\texttt{A=500,  B=0, \$balanceA=100})}  & \\
& \makecell[tl]{Calculate \textsc{a}'s new balance \\ \hspace{12px} (\texttt{A=500, B=0, \$balanceA=100})} \\
\makecell[tl]{Store money transfer \\ \hspace{12px} (\texttt{A=100, B=400, \$balanceA=100})} & \\
& \makecell[tl]{Store money transfer \\ \hspace{12px} (\texttt{\textcolor{red}{A=100, B=800}, \$balanceA=100})} \\ \hline
\end{tabular}
\caption{Parallel execution of two concurrent money transfer requests. \\ \texttt{A} and \texttt{B} represent the stored values of \textsc{a}'s and \textsc{b}'s balances}
\label{tab:toctou}
\end{table}

\noindent
At the end of the process, \textsc{b} would end up with twice the money he was intended to receive, while the correct amount of money was taken from \textsc{a}. Notice that the problem resides in the fact that the check of \textsc{a}'s initial balance and its subsequent update are two distinct (non-atomic) operations.

\subsection{Purposed solution}

An easy way of resolving the problem is leveraging the atomicity of database queries:

\begin{minted}[startinline, breaklines, samepage]{php}
// Update A's balance only if she has at least 400$
query("UPDATE users SET balance = balance - 400 WHERE id = A AND balance >= 400");

// Check if the balance was actually updated
if (affected_rows == 0) {
    die("Insufficient balance");
}

// Update B's balance
query("UPDATE users SET balance = balance + 400 WHERE id = B");
\end{minted}

\noindent
The problem is now gone because the first query checks the balance and updates it in one shot. An even better solution would be to wrap both queries in an SQL transaction and commit only after everything is done.
